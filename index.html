<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3_PWSH_TITLE</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/styles/default.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.2.96/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/beercss@3.7.8/dist/cdn/beer.min.css" rel="stylesheet">
  <style>
    body { margin: 0 }
    .tooltip { opacity: 1 !important; }
    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%; /* aspect ratio */
        vertical-align: middle;
        overflow: auto;
    }
    .svg-content-responsive {
        display: inline-block;
        position: absolute;
        top: 10px;
        left: 0;
    }
  </style>
</head>
<body>
  <div id="app">
    <main>
      <div id='spinner-overlay' class="overlay" style="z-index: 10002"></div>
      <div id='blurred-overlay' class="overlay blur"></div>
      
      <dialog id="dialog-custom-overlay" class="max no-padding no-margin">
        <div class="no-padding no-margin">
            <nav id="topNav" class="tabbed no-round no-space">
              <a data-ui="#authorList" class="active"><i>face</i><span>Author</span></a>
              <a data-ui="#companyNameList"> <i>apartment</i><span>Company</span></a>
              <a data-ui="#tagList" class="disabled"><i>sell</i><span>Tag</span></a>
            </nav>
            <div id="authorList" class="page top-padding bottom-padding left-padding active"></div>
            <div id="companyNameList" class="page top-padding bottom-padding left-padding "></div>
            <div id="tagList" class="page top-padding bottom-padding left-padding">Not Implemented</div>
        </div>
        <nav id="bottomNav" class="right-align fixed bottom round fill padding no-margin">
          <button class="border white" data-ui="#dialog-custom-overlay">
            <i>close</i>
            <span>Cancel</span>
          </button>
        </nav>
      </dialog>

      <div id="chart"></div>

      <div class="fixed top left margin">
          <button id="buttonSelection" data-ui="#dialog-custom-overlay" class="" style="visibility: hidden;">Select ...</button>
      </div>

    </main>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/page-js@1.7.3/page.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.1/highlight.min.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/beercss@3.7.8/dist/cdn/beer.min.js"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/material-dynamic-colors@1.1.2/dist/cdn/material-dynamic-colors.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>

      // the resources.json json file contains the list of resources to load must be formatted as follows:
      // [
      //   {
      //     "name": "Resource Name",
      //     "category": "Category Name",
      //     "count" : 2,
      //     "url": "path/to/resource.json"
      //   }
      // ]

      document.addEventListener('DOMContentLoaded', function() {

        var resourcesFile = 'AllPSGallery/resources.json';
      
        var paramsString = decodeURI(window.location.href).split("#")[1];
        let searchParams = new URLSearchParams(paramsString);

        var blurredOverlay = document.getElementById('blurred-overlay');
        var spinnerOverlay = document.getElementById('spinner-overlay');
        var dialog = document.getElementById('dialog-custom-overlay');
        
        // Create a progress spinner with BeerCSS and Material Design Icons
        var loadingOverlay = document.createElement('div');
        loadingOverlay.style.position = 'fixed';
        loadingOverlay.style.top = '0';
        loadingOverlay.style.left = '0';
        loadingOverlay.style.width = '100%';
        loadingOverlay.style.height = '100%';
        loadingOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        loadingOverlay.style.display = 'flex';
        loadingOverlay.style.justifyContent = 'center';
        loadingOverlay.style.alignItems = 'center';
        loadingOverlay.style.zIndex = '10001';

        var loading = document.createElement('progress');
        loading.className = 'circle large';

        loadingOverlay.appendChild(loading);
        spinnerOverlay.appendChild(loadingOverlay);
        
        fetch(resourcesFile)
            .then(res => res.json())
            .then(data => {
                console.log("resources data loaded:", data);

                var categories = {};
                
                data.forEach(function(item) {
                    if (!categories[item.type]) {
                        categories[item.type] = [];
                    }
                    categories[item.type].push(item);
                });

                // Create menu structure
                for (var category in categories) {
                    var pre = document.createElement('div');
                    pre.className = 'scroll no-padding bottom-margin large-margin';
                    // set the max height of the pre element based on the window height
                    pre.style = 'max-height: ' + (window.innerHeight - document.getElementById('topNav').clientHeight - document.getElementById('bottomNav').clientHeight) + 'px;';
                    categories[category].forEach(function(item) {
                        var button = document.createElement('button');
                        button.className = 'chip no-margin';
                        button.style = 'margin-bottom: 5px !important;margin-right: 5px !important;';
                        var span = document.createElement('span');
                        span.textContent = item.name.replace(/_/g, ' ');
                        button.appendChild(span);

                        var badge = document.createElement('div');
                        badge.className = 'badge none';
                        badge.textContent = item.count.replace(/0+(\d+)/, '$1');
                        button.appendChild(badge);
                        
                        button.onclick = function(event) {
                            event.preventDefault();
                            spinnerOverlay.classList.add('active');
                            var jsonFilePath = item.url;
                            
                            var existingSunburst = document.getElementById('chart');
                            // Remove the previous sunburst chart if it exists
                            if (existingSunburst) {
                                while (existingSunburst.firstChild) {
                                    existingSunburst.removeChild(existingSunburst.firstChild);
                                }
                            }
                            
                            fetch(jsonFilePath)
                                .then(res => res.json())
                                .then(data => {
                                    console.log("data loaded:", data);
                                    createSunburstChart(data);
                                    // add 500 ms delay to show the spinner
                                    setTimeout(() => {
                                        spinnerOverlay.classList.remove('active');
                                        console.log("Spinner removed from the document body");
                                        blurredOverlay.classList.remove('active');
                                        dialog.classList.remove('active');
                                        dialog.close();
                                        console.log("dialog closed");
                                    }, 500);
                                })
                                .catch(err => {
                                    console.error("Error loading resource data:", err);
                                    setTimeout(() => {
                                        spinnerOverlay.classList.remove('active');
                                        console.log("Spinner removed from the document body");
                                        blurredOverlay.classList.remove('active');
                                        dialog.classList.remove('active');
                                        dialog.close();
                                        console.log("dialog closed");
                                    }, 500);
                                });
                        };

                        pre.appendChild(button);
                    });
                    var categoryList = document.getElementById(category + 'List');
                    categoryList.appendChild(pre);

                }

                if (searchParams.has("author") === true) {
                    var author = searchParams.get("author");
                    // find the button with the author name and click it
                    // the button has a span with the author in it
                    // button > span > textContent = author
                    // this code will not work : document.querySelector('button:contains("' + author + '")');
                    document.querySelectorAll('button span').forEach((span) => {
                        if (span.innerHTML === author) {
                            span.parentElement.click();
                        }
                    });
                } else if (searchParams.has("companyName") === true) {
                    var companyName = searchParams.get("companyName");
                    var companyNameButton = document.querySelector('button:contains("' + companyName + '")');
                    if (companyNameButton) {
                        companyNameButton.click();
                    }
                } else {
                  dialog.showModal();
                }

                var buttonSelection = document.getElementById('buttonSelection');
                buttonSelection.style.visibility = 'visible';
            })
            .catch(err => console.error("Error loading resources file:", err));
      });
      
      function createSunburstChart(data) {
        
        // if data count is over 100 items, then only show the top 100 items
        if (data.children.length > 100) {
          data.children = data.children.slice(0, 100);
        }

        const width =  window.innerWidth, // document.documentElement.scrollWidth - 20,
              height = window.innerHeight,
              centerX = width/2,
              centerY = height/2;
        
        var startAngle = 0, // the starting angle for the sunburst
            endAngle = 2 * Math.PI, // the ending angle for the sunburst
            radius = Math.min(width, height)/2 - 8,
            padRadius = radius/4;

        // Create the color scale.
        const color = d3.scaleOrdinal(d3.quantize(d3.interpolateSinebow, data.children.length + 1));

        const shadow = true;
        const black  = true;
        
        // Compute the layout.
        const hierarchy = d3.hierarchy(data)
                            .each(function (d) { 
                              if (d.depth && d.depth > 0 && d.parent && d.parent.value && d.parent.children) {
                                  d.value = d.parent.value/d.parent.children.length;
                              } else {
                                d.value = 360;
                              }
                            })
                            .sort((a,b) => a.data.name.localeCompare(b.data.name));
            
        const root = d3.partition()
                      .size([endAngle - startAngle, hierarchy.height + 2])
                      (hierarchy);
          
        root.each(d => d.current = d);

        // Create the arc generator.
        const arc = d3.arc()
                      .startAngle(d => d.x0 + startAngle)
                      .endAngle(d => d.x1 + startAngle)
                      .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
                      .padRadius(padRadius)
                      .innerRadius(d => radius/6)
                      .outerRadius(d => radius);

        // Create the SVG container.
        const svg = d3.select("#chart")
                      .append("div")
                      .classed("svg-container", true) 
                      .append("svg")
                        // .classed("svg-content-responsive", true)
                        .attr("viewBox", [-width/2, - height/2, width, height])
                        .attr("preserveAspectRatio", "xMinYMin meet")
                        .attr("font-size", 12)
                        .attr("font-family", "Segoe UI, Noto Sans, Helvetica, Arial, sans-serif");

        const format = d3.format(",d");
        
        // Append the arcs.
        const path = svg.append("g")
                        .selectAll("path")
                        .data(root.descendants().slice(1))
                        .join("path")
                          .attr("class", "node-path")
                          .attr("fill", d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })
                          .attr("fill-rule", "evenodd")
                          .attr("fill-opacity", d => arcVisible(d.current) ? 0.5 : 0)
                          .attr("pointer-events", d => arcVisible(d.current) ? "auto" : "none")
                          .attr("d", d => arc(d.current));

        // Make them clickable if they have children.
        path//.filter(d => d.children)
            .style("cursor", "pointer")
            .on("click", clicked)
            .on("mouseenter", (event, el) => {
              event.target.setAttribute("stroke", event.target.getAttribute("fill"));
              event.target.setAttribute("stroke-width", 4);
              event.target.setAttribute("fill-opacity", 1.0);
            })
            .on("mouseover", (event, el) => {
              event.target.setAttribute("stroke", event.target.getAttribute("fill"));
              event.target.setAttribute("stroke-width", 4);
              event.target.setAttribute("fill-opacity", 1.0);
            })
            .on("mouseleave", (event, el) => {
              event.target.setAttribute("stroke", "transparent");
              event.target.setAttribute("stroke-width", 0);
              event.target.setAttribute("fill-opacity", 0.5);
            })
            .on("mouseout", (event, el) => {
              event.target.setAttribute("stroke", "transparent");
              event.target.setAttribute("stroke-width", 0);
              event.target.setAttribute("fill-opacity", 0.5);
            });

        path.append("title")
            .text(function(d) {
              var ancestors = d.ancestors().filter(d => d.depth > 0 && d.depth != 2);
              var text = ancestors.map(d => d.data.name).reverse().join("\\");
              return text; 
          });

        const label = svg.append("g")
                        .attr("class", "node-label")
                        .attr("pointer-events", "none")
                        .style("user-select", "none")
                        .selectAll("text")
                        .data(root.descendants().slice(1))
                        .join("text")
                          .attr("class", "node-text")
                          .attr("fill", "#000")
                          .attr("fill-opacity", d => +labelVisible(d.current))
                          /*
                          .attr("font-size", function (d) {
                              var space = getAvailableLabelSpace(d);
                              var fontSize = getFontSizeToFit(space, d.data.name, "Segoe UI");
                              return fontSize;
                           })
                          */
                          .attr("text-shadow", function(){
                                if (shadow) {
                                    return black ? "2px 2px 0px white" : "2px 2px 0px black";
                                } else {
                                    return "none";
                                }
                           })
                          .attr("font-weight", "bold")
                          .attr("text-anchor", d => labelAnchor(d.current))
                          .attr("dx", d => labelDx(d.current))
                          .attr("dy", d => labelDy(d.current))
                          .attr("transform", d => labelTransform(d))
                          .text(d => d.data.name);

        const parent = svg.append("circle")
                          .datum(root)
                          .attr("class", "node-parent")
                          .attr("r", radius/6 - 5)
                          .attr("fill", "#CCC")
                          .attr("fill-opacity", 0.5)
                          .on("mouseenter", (event, el) => {
                            event.target.setAttribute("fill-opacity", 1.0);
                            event.target.setAttribute("stroke", "#BBB");
                            event.target.setAttribute("stroke-width", 1);
                          })
                          .on("mouseout", (event, el) => {
                            event.target.setAttribute("fill-opacity", 0.5);
                            event.target.setAttribute("stroke", "transparent");
                            event.target.setAttribute("stroke-width", 1);
                          })
                          .attr("pointer-events", "all")
                          .on("click", clicked);

        console.log("Data:", data);
        console.log("Hierarchy:", hierarchy);
        console.log("Root:", root);

        // Handle zoom on click.
        function clicked(event, p) {
          
          parent.datum(p.parent || root);

          root.each(d => d.target = {
            x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
            x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,
            y0: Math.max(0, d.y0 - p.depth),
            y1: Math.max(0, d.y1 - p.depth)
          });

          const t = svg.transition().duration(750);

          // Transition the data on all arcs, even the ones that aren’t visible,
          // so that if this transition is interrupted, entering arcs will start
          // the next transition from the desired position.
          path.transition(t)
              .tween("data", d => {
                const i = d3.interpolate(d.current, d.target);
                return t => d.current = i(t);
              })
              .filter(function(d) {
                return +this.getAttribute("fill-opacity") || arcVisible(d.target);
              })
              .attr("fill-opacity", d => arcVisible(d.target) ? 0.5 : 0)
              .attr("pointer-events", d => arcVisible(d.target) ? "auto" : "none")
              .attrTween("d", d => () => arc(d.current));

          label.filter(function(d) {
                return +this.getAttribute("fill-opacity") || labelVisible(d.target);
                })
              .transition(t)
              .attr("fill-opacity", d => +labelVisible(d.target))
              .attr("text-anchor", d => labelAnchor(d.target))
              .attr("dx", d => labelDx(d))
              .attr("dy", d => labelDy(d))
              .attrTween("transform", d => () => labelTransform(d));
        }
        
        function arcHover(event, p) {
        }

        function arcVisible(d) {
          return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;
        }

        function labelVisible(d) {
          return d.y1 <= 3 && 
                 d.y0 >= 1 && 
                 (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
        }

        function labelAnchor(d) {
          var x = ((d.x0 + d.x1) / 2 * 180 / Math.PI);
          if (x >= 0 && x < 180) {
              return `end`;
          } else if (x >= 180 && x <= 360) {
            return `start`;
          }  
        }
        
        function labelDy(d) {
          /*
          var height = (d.y0 + d.y1) / 2;
          var dy = height;
          const y = (d.y0 + d.y1) / 6 * radius;
          if (y < 180) {
            dy = -dy;
          }
          */
          var dy = 0;
          return `${dy}em`;
        }

        function labelDx(d) {
          var count = d.parent ? d.parent.children.length : d.children.length;
          /*
          var node = d3.select(".node-text");
          var fontSize = node.attr("font-size");
          var textLength = d.data.name.length;
          var width = (d.x0 + d.x1) / 2;
          var x = ((d.x0 + d.x1) / 2 * 180 / Math.PI);
          // var dx = width;
          if (x >= 180 && x <= 360) {
              dx = -dx;
          }
          */
          // var fontSize = getFontSizeToFit(getAvailableLabelSpace(d), d.data.name, "Segoe UI");
          
          // console.log("x:", x, d.data.name, d.depth);
          var dx = 8 - (d.depth*2) - 1 ;// - (fontSize*0.1)

          if (d.target) {
            var x = ((d.target.x0 + d.target.x1) / 2 * 180 / Math.PI);
          } else {
            var x = ((d.x0 + d.x1) / 2 * 180 / Math.PI);
          }

          if (count == 1) {
            dx = dx + 3;
          } else {
            if (x >= 0 && x < 180) {
                dx = dx;
            } else if (x >= 180 && x <= 360) {
                dx = -dx;
            }
          }
          return `${dx}em`;
          // return `0em`;
        }

        function labelTransform(d) {
          console.log("d:", d);
          var count = d.parent && d.parent.children ? d.parent.children.length : d.children.length;
          /*
          var count = d.parent ? d.parent.children.length : d.children.length;
          var angle = 360 / count;
          */ 

          if (d.current) {
              var x = (d.current.x0 + d.current.x1) / 2 * 180 / Math.PI;
              var y = (d.current.y0 + d.current.y1) / 6 * radius;
          } else {
              var x = ((d.x0 + d.x1) / 2 * 180 / Math.PI);
              var y = (d.y0 + d.y1) / 6 * radius;
          }
          
          var rotation = x - 90;
          var xTranslation =  y;
          var yTranslation = 0;
          var rotation2 = (x < 180 ? 0 : 180);

          // console.log("name, count, rotation, x, y:\n", d.data.name, count, rotation, x, y);

          if (count == 1) {
            xTranslation = 0 ; //d.target ? -((d.target.x0 + d.target.x1)/2) : -((d.x0 + d.x1)/2);
            yTranslation = -y;
            return `${rotate} translate(${xTranslation}, ${yTranslation})`;
          } else if (count == 33333) {
            // there is enough space for 3 labels so we don't need to rotate the labels
            // but we need to fix xTranslation and yTranslation like we are rotating the labels with rotation
            if (rotation == 0) {
              xTranslation = y/2;
              yTranslation = -y;
            } if (rotation == 90) {
              xTranslation = y/2;
              yTranslation = y;
            } else if (rotation < 180) {
              xTranslation = y;
            } else if (rotation > 180 ) {
              xTranslation = -y;
            }
            return `translate(${xTranslation}, ${yTranslation})`;
          }
          var rotate =  `rotate(${rotation})`;
          var translate = `translate(${xTranslation}, ${yTranslation})`;
          var rotate2 =  `rotate(${rotation2})`;
          return `${rotate} ${translate} ${rotate2}`;
        }

        function getAvailableLabelSpace(d) {
          if (d.target) {
            var arcWidth = d.target.x1 - d.target.x0;
          } else {
            var arcWidth = d.x1 - d.x0;
          }
          var availableSpace = arcWidth * radius;
          return availableSpace;
        }

        function measureTextWidth(text, fontSize, fontFamily) {
          const ctx = new OffscreenCanvas(0, 0).getContext('2d');
          if (!ctx) return 0;
          ctx.font = `${fontSize}px ${fontFamily}`;
          return ctx.measureText(text).width;
        }

        function getFontSizeToFit(availableWidthPx, text, fontFamily, minFontSize = 12, maxFontSize = 32) {
          const fontSize = (availableWidthPx / measureTextWidth(text, 12, fontFamily)) * 12;
          return fontSize < minFontSize ? minFontSize : Math.min(maxFontSize, fontSize);
        }

      }

  </script>
</body>
</html>